<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MEGWIN OBS Overlay</title>
<style>
    /* 背景は完全に透明 */
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; 
        background-color: transparent !important;
        font-family: 'Impact', 'Arial Black', sans-serif;
    }
    
    /* グリッドコンテナ */
    #grid-container { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        display: grid; 
        grid-template-columns: repeat(var(--cols), 1fr); 
        grid-template-rows: repeat(var(--rows), 1fr); 
        pointer-events: none; z-index: 10; 
    }
    
    /* ブロックのデザイン（完全な黒） */
    .block { 
        width: 100%; height: 100%; 
        background-color: black; 
        opacity: 0; 
        transform: scale(0.1); 
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    }
    .block.active { 
        opacity: 1; transform: scale(1); 
        animation: glitch-appear 0.3s ease-out; 
    }
    @keyframes glitch-appear { 
        0% { box-shadow: 0 0 15px #0f0 inset; border: 1px solid #0f0; } 
        100% { box-shadow: 0 0 0 rgba(0,0,0,0) inset; border: none; } 
    }

    /* ゲームオーバー文字 */
    #game-over { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        color: #ff0000; font-size: 10rem; font-weight: bold; opacity: 0; z-index: 30; 
        text-shadow: 5px 5px 0 #000, -5px -5px 0 #000, 5px -5px 0 #000, -5px 5px 0 #000, 0 0 30px #ff0000; 
        pointer-events: none; transition: opacity 0.3s ease-in; 
        white-space: nowrap; letter-spacing: 15px; font-family: 'Impact', sans-serif;
    }

    /* 下部の説明バー（タイトル） */
    /* ★変更：100px上に移動 (150px -> 250px) */
    #status-bar { 
        position: absolute; bottom: 250px; left: 50%; transform: translateX(-50%); 
        color: #fff; background: rgba(0, 0, 0, 0.8); padding: 15px 50px; 
        border: 4px solid #fff; z-index: 100; font-size: 32px; border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.8); text-align: center; white-space: nowrap;
    }

    /* タイマー表示 */
    /* ★変更：タイトルのさらに上に配置 */
    #timer-container {
        position: absolute; bottom: 340px; 
        left: 50%; transform: translateX(-50%);
        text-align: center; z-index: 100;
    }
    #timer-label {
        color: #ddd; font-size: 1.5rem; letter-spacing: 2px;
        text-shadow: 2px 2px 0 #000; display: block;
    }
    #timer-display {
        font-size: 5rem; font-weight: bold; color: #fff;
        text-shadow: 4px 4px 0 #000; 
        font-variant-numeric: tabular-nums; letter-spacing: 5px;
        line-height: 1;
    }
    
    /* アクションユーザー表示 */
    #user-action-display {
        position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
        font-size: 3.5rem; font-weight: bold; color: yellow;
        text-shadow: 3px 3px 0 #000, -2px -2px 0 #000;
        opacity: 0; transition: opacity 0.5s; z-index: 50;
        background: rgba(0,0,0,0.6); padding: 15px 40px; border-radius: 20px;
        display: flex; align-items: center; gap: 20px;
        white-space: nowrap;
    }
    .user-icon {
        width: 80px; height: 80px;
        border-radius: 50%; border: 4px solid white; object-fit: cover;
    }

    .text-red { color: #ff4444; }
    .text-green { color: #44ff44; }
    .system-off #grid-container { opacity: 0.1; }
</style>
</head>
<body>
    <div id="grid-container"></div>
    <div id="game-over">GAME OVER</div>
    
    <div id="timer-container">
        <span id="timer-label">経過時間</span>
        <div id="timer-display">00:00:00</div>
    </div>

    <div id="user-action-display"></div>
    
    <div id="status-bar">闇VS光　コメントorスパチャ</div>

    <script>
        const MAX_DARKNESS = 20000; 
        const INITIAL_DARKNESS = 10000; 
        
        // 1対1のガチンコ設定（1発100ポイント）
        const BASE_MULTIPLIER = 0.2; 

        const GRID_COLS = 32; 
        const GRID_ROWS = 18; 

        let currentDarkness = INITIAL_DARKNESS; 
        let spiralOrder = []; 
        let isActive = true;

        // タイマー用変数
        let startTime = null;
        let timerInterval = null;
        let isGameOver = false;

        const container = document.getElementById('grid-container'); 
        const gameOverText = document.getElementById('game-over');
        const userActionDisplay = document.getElementById('user-action-display');
        const timerDisplay = document.getElementById('timer-display');

        container.style.setProperty('--cols', GRID_COLS); 
        container.style.setProperty('--rows', GRID_ROWS);

        // --- タイマー関数 ---
        function startTimer() {
            startTime = Date.now();
            isGameOver = false;
            timerDisplay.style.color = "#fff"; 
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 100); 
        }

        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
        }

        function updateTimer() {
            if (!startTime) return;
            const diff = Math.floor((Date.now() - startTime) / 1000);
            
            const h = Math.floor(diff / 3600).toString().padStart(2, '0');
            const m = Math.floor((diff % 3600) / 60).toString().padStart(2, '0');
            const s = (diff % 60).toString().padStart(2, '0');
            
            timerDisplay.innerText = `${h}:${m}:${s}`;
        }
        // ------------------

        function connectWS() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(protocol + '//' + window.location.host + '/ws');
            
            ws.onmessage = (event) => { 
                const data = JSON.parse(event.data); 
                
                if (data.type === 'damage') {
                    addDarkness(data.amount);
                    showUserAction(data.user, data.icon, "闇", "red", null);
                }
                else if (data.type === 'heal') {
                    removeDarkness(data.amount);
                    if (data.money) {
                        showUserAction(data.user, data.icon, "光", "#0f0", data.money);
                    } else {
                        showUserAction(data.user, data.icon, "光", "#0f0", null);
                    }
                }
                else if (data.type === 'status_change') {
                    if (data.is_active && !isActive) {
                        currentDarkness = INITIAL_DARKNESS;
                        updateVisuals();
                        startTimer(); // システムONでスタート
                    }
                    else if (!data.is_active) {
                        stopTimer(); // システムOFFでストップ
                    }
                    updateSystemState(data.is_active);
                }
            };
            ws.onclose = () => { setTimeout(connectWS, 3000); };
        }

        let hideTimeout;
        function showUserAction(name, iconUrl, type, color, money) {
            // ゲームオーバー中はユーザー名も出さない（完全沈黙）
            if (currentDarkness >= MAX_DARKNESS) return;

            if (!name) return;
            const safeIcon = iconUrl ? iconUrl : "https://cdn-icons-png.flaticon.com/512/847/847969.png";
            let html = `<img src="${safeIcon}" class="user-icon">`;
            html += `<span><span style="color:${color}">${name}</span>`;
            if (money) {
                html += ` が <span style="color:gold; font-size:1.2em;">${money}</span> の${type}を送った！</span>`;
            } else {
                html += ` が ${type} を送った！</span>`;
            }
            userActionDisplay.innerHTML = html;
            userActionDisplay.style.opacity = 1;
            clearTimeout(hideTimeout);
            hideTimeout = setTimeout(() => { userActionDisplay.style.opacity = 0; }, 3000);
        }

        function updateSystemState(active) {
            isActive = active;
            if (isActive) document.body.classList.remove("system-off");
            else document.body.classList.add("system-off");
        }

        function initGrid() {
            let gridMap = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
            for (let r = 0; r < GRID_ROWS; r++) { for (let c = 0; c < GRID_COLS; c++) { const block = document.createElement('div'); block.classList.add('block'); container.appendChild(block); gridMap[r][c] = block; } }
            
            let top = 0, bottom = GRID_ROWS - 1, left = 0, right = GRID_COLS - 1; let dir = 0;
            while (top <= bottom && left <= right) {
                if (dir === 0) { for (let i = left; i <= right; i++) spiralOrder.push(gridMap[top][i]); top++; }
                else if (dir === 1) { for (let i = top; i <= bottom; i++) spiralOrder.push(gridMap[i][right]); right--; }
                else if (dir === 2) { for (let i = right; i >= left; i--) spiralOrder.push(gridMap[bottom][i]); bottom--; }
                else if (dir === 3) { for (let i = bottom; i >= top; i--) spiralOrder.push(gridMap[i][left]); left++; }
                dir = (dir + 1) % 4;
            }
            updateVisuals();
        }

        function updateVisuals() {
            const blocksToDraw = Math.floor((currentDarkness / MAX_DARKNESS) * spiralOrder.length);
            for(let i=0; i<spiralOrder.length; i++) {
                if (i < blocksToDraw) spiralOrder[i].classList.add('active');
                else spiralOrder[i].classList.remove('active');
            }
            // ゲームオーバー判定
            if (currentDarkness >= MAX_DARKNESS) {
                gameOverText.style.opacity = 1;
                if (!isGameOver) {
                    isGameOver = true;
                    stopTimer(); // タイマーストップ
                    timerDisplay.style.color = "red"; // タイマー赤文字
                }
            } else {
                gameOverText.style.opacity = 0;
            }
        }

        function addDarkness(amount) { 
            if (currentDarkness >= MAX_DARKNESS) return; 
            currentDarkness = Math.min(currentDarkness + (amount * BASE_MULTIPLIER), MAX_DARKNESS); 
            updateVisuals(); 
        }

        function removeDarkness(amount) { 
            // ゲームオーバーなら光は無視
            if (currentDarkness >= MAX_DARKNESS) return;
            if (currentDarkness <= 0) return; 
            
            currentDarkness = Math.max(currentDarkness - (amount * BASE_MULTIPLIER), 0); 
            updateVisuals(); 
        }
        
        initGrid(); 
        connectWS();
        fetch('/api/status').then(r => r.json()).then(d => {
            updateSystemState(d.is_active);
            if(d.is_active) startTimer();
        });
    </script>
</body>
</html>
