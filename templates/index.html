<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MEGWIN OBS Overlay (Debug Mode)</title>
<style>
    /* èƒŒæ™¯ï¼šãƒ‡ãƒãƒƒã‚°ä¸­ã¯ã€Œè–„ã„ã‚°ãƒ¬ãƒ¼ã€ã«ã—ã¦ã€é€æ˜ãªãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ãˆã‚‹ã‹ç¢ºèªã—ã‚„ã™ãã—ã¾ã™ */
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; 
        background-color: #333; /* æœ¬ç•ªã¯ transparent ã«æˆ»ã—ã¾ã™ */
        font-family: 'Arial', sans-serif;
    }
    
    /* ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ */
    #grid-container { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        display: grid; 
        grid-template-columns: repeat(var(--cols), 1fr); 
        grid-template-rows: repeat(var(--rows), 1fr); 
        pointer-events: none; z-index: 10; 
    }
    
    /* ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
    .block { 
        width: 100%; height: 100%; 
        background-color: rgba(0, 0, 0, 0.9); 
        opacity: 0.2; /* ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæœªç™ºå‹•ã§ã‚‚ã†ã£ã™ã‚‰è¡¨ç¤º */
        transform: scale(0.9); /* ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šéš™é–“ã‚’é–‹ã‘ã‚‹ */
        border: 1px solid #555; /* ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ ç·š */
        transition: all 0.2s;
    }
    .block.active { 
        opacity: 1; transform: scale(1); border: none;
        background-color: black;
        box-shadow: 0 0 10px #0f0; /* ç™ºå‹•ã—ãŸã‚‰å…‰ã‚‹ */
    }

    /* ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤ºãƒ‘ãƒãƒ«ï¼ˆç”»é¢å·¦ä¸Šï¼‰ */
    #debug-console {
        position: absolute; top: 10px; left: 10px;
        background: rgba(0,0,0,0.8); color: lime;
        padding: 10px; font-family: monospace; font-size: 16px;
        z-index: 9999; pointer-events: none;
        white-space: pre-wrap; border: 2px solid lime;
        max-width: 500px;
    }

    /* ã‚²ãƒ¼ã‚¸ï¼ˆç”»é¢ä¸‹éƒ¨ï¼‰ */
    #status-bar { 
        position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); 
        color: #0f0; background: rgba(0, 0, 0, 0.85); padding: 15px 40px; 
        border: 3px solid #0f0; z-index: 100; font-family: 'Courier New', monospace; 
        font-weight: bold; font-size: 32px; border-radius: 10px;
    }
</style>
</head>
<body>
    <div id="debug-console">èª­ã¿è¾¼ã¿ä¸­...</div>

    <div id="grid-container"></div>
    <div id="status-bar">DANGER: <span id="score-val">---</span></div>

    <script>
        const debugConsole = document.getElementById('debug-console');
        function log(msg) {
            const time = new Date().toLocaleTimeString();
            debugConsole.innerText = `[${time}] ${msg}\n` + debugConsole.innerText;
        }
        window.onerror = function(message, source, lineno, colno, error) {
            log(`âŒ ERROR: ${message}`);
        };

        log("ğŸš€ ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•é–‹å§‹...");

        // è¨­å®š
        const MAX_DARKNESS = 20000; 
        const INITIAL_DARKNESS = 10000; 
        const DAMAGE_MULTIPLIER = 1.2; 
        const GRID_COLS = 32; 
        const GRID_ROWS = 18; 

        let currentDarkness = INITIAL_DARKNESS; 
        let spiralOrder = []; 
        let isActive = true;

        const container = document.getElementById('grid-container'); 
        const scoreVal = document.getElementById('score-val'); 

        // CSSå¤‰æ•°ã‚»ãƒƒãƒˆ
        container.style.setProperty('--cols', GRID_COLS); 
        container.style.setProperty('--rows', GRID_ROWS);

        // WebSocketæ¥ç¶š
        function connectWS() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.host;
                const wsUrl = protocol + '//' + host + '/ws';
                
                log(`ğŸ“¡ æ¥ç¶šè©¦è¡Œ: ${wsUrl}`);
                const ws = new WebSocket(wsUrl);

                ws.onopen = () => { log("âœ… ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šæˆåŠŸï¼(ONLINE)"); };
                ws.onmessage = (event) => { 
                    log(`ğŸ“© å—ä¿¡: ${event.data}`); // å—ä¿¡ãƒ‡ãƒ¼ã‚¿ã‚’è¦‹ã‚‹
                    try {
                        const data = JSON.parse(event.data); 
                        if (data.type === 'damage') addDarkness(data.amount); 
                        else if (data.type === 'heal') removeDarkness(data.amount);
                        else if (data.type === 'status_change') {
                            isActive = data.is_active;
                            log(`â„¹ï¸ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å¤‰æ›´: ${isActive}`);
                        }
                    } catch(e) {
                        log(`âš ï¸ ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: ${e}`);
                    }
                };
                ws.onclose = (e) => { 
                    log(`âŒ åˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚3ç§’å¾Œã«å†æ¥ç¶š... (${e.code})`); 
                    setTimeout(connectWS, 3000); 
                };
                ws.onerror = (e) => { log("âš ï¸ WebSocketã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ"); };

            } catch (e) {
                log(`âŒ æ¥ç¶šå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${e}`);
            }
        }

        function initGrid() {
            log(`ğŸ§© ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ: ${GRID_COLS}x${GRID_ROWS}`);
            let gridMap = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
            
            // ãƒ–ãƒ­ãƒƒã‚¯é…ç½®
            for (let r = 0; r < GRID_ROWS; r++) { 
                for (let c = 0; c < GRID_COLS; c++) { 
                    const block = document.createElement('div'); 
                    block.classList.add('block'); 
                    container.appendChild(block); 
                    gridMap[r][c] = block; 
                } 
            }
            
            // æ¸¦å·»ãè¨ˆç®—
            let top = 0, bottom = GRID_ROWS - 1, left = 0, right = GRID_COLS - 1; let dir = 0;
            while (top <= bottom && left <= right) {
                if (dir === 0) { for (let i = left; i <= right; i++) spiralOrder.push(gridMap[top][i]); top++; }
                else if (dir === 1) { for (let i = top; i <= bottom; i++) spiralOrder.push(gridMap[i][right]); right--; }
                else if (dir === 2) { for (let i = right; i >= left; i--) spiralOrder.push(gridMap[bottom][i]); bottom--; }
                else if (dir === 3) { for (let i = bottom; i >= top; i--) spiralOrder.push(gridMap[i][left]); left++; }
                dir = (dir + 1) % 4;
            }
            log(`ğŸ§© ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆå®Œäº†: ${spiralOrder.length}å€‹`);
            updateVisuals();
        }

        function updateVisuals() {
            scoreVal.innerText = Math.floor(currentDarkness);
            const blocksToDraw = Math.floor((currentDarkness / MAX_DARKNESS) * spiralOrder.length);
            
            // UIæ›´æ–°
            for(let i=0; i<spiralOrder.length; i++) {
                if (i < blocksToDraw) spiralOrder[i].classList.add('active');
                else spiralOrder[i].classList.remove('active');
            }
        }

        function addDarkness(amount) { 
            if (currentDarkness >= MAX_DARKNESS) return; 
            currentDarkness = Math.min(currentDarkness + (amount * DAMAGE_MULTIPLIER), MAX_DARKNESS); 
            updateVisuals(); 
        }

        function removeDarkness(amount) { 
            if (currentDarkness <= 0) return; 
            currentDarkness = Math.max(currentDarkness - amount, 0); 
            updateVisuals(); 
        }
        
        // å®Ÿè¡Œ
        window.onload = function() {
            initGrid(); 
            connectWS();
        };
    </script>
</body>
</html>
