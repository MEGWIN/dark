<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MEGWIN OBS Overlay</title>
<style>
    /* 背景を完全に透明に */
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; 
        background-color: transparent !important; /* 強制透明 */
    }
    
    /* グリッドコンテナ */
    #grid-container { 
        position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; 
        display: grid; 
        grid-template-columns: repeat(var(--cols), 1fr); 
        grid-template-rows: repeat(var(--rows), 1fr); 
        pointer-events: none; z-index: 10; 
    }
    
    /* ブロックのデザイン（黒） */
    .block { 
        width: 100%; height: 100%; 
        background-color: rgba(0, 0, 0, 0.95); 
        opacity: 0; transform: scale(0.1); 
        border-radius: 20%; 
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    }
    .block.active { 
        opacity: 1; transform: scale(1); border-radius: 0%; 
        animation: glitch-appear 0.5s ease-out; 
    }
    
    @keyframes glitch-appear { 
        0% { box-shadow: 0 0 15px #0f0 inset; border: 1px solid #0f0; } 
        100% { box-shadow: 0 0 0 rgba(0,0,0,0) inset; border: 0px solid transparent; } 
    }

    /* エフェクトレイヤー */
    #damage-flash, #heal-flash { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        pointer-events: none; z-index: 20; transition: background-color 0.1s; 
    }
    #damage-flash { background-color: rgba(255, 0, 0, 0); }
    #heal-flash { background-color: rgba(255, 255, 255, 0); }

    /* ゲームオーバー文字 */
    #game-over { 
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
        color: red; font-size: 8rem; font-weight: bold; opacity: 0; z-index: 30; 
        text-shadow: 5px 5px 0 #000; font-family: 'Impact', sans-serif; pointer-events: none; 
        transition: opacity 0.5s; white-space: nowrap;
    }

    /* ゲージ（画面下部） */
    #status-bar { 
        position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); 
        color: #0f0; background: rgba(0, 0, 0, 0.85); padding: 15px 40px; 
        border: 3px solid #0f0; z-index: 100; font-family: 'Courier New', monospace; 
        font-weight: bold; font-size: 32px; box-shadow: 0 0 15px #0f0; 
        border-radius: 10px;
    }
    
    /* 接続状態（小さく表示、透明背景でも見えるように） */
    #connection-status { 
        position: absolute; top: 10px; left: 10px; 
        color: rgba(255, 255, 0, 0.5); font-size: 10px; z-index: 9999; 
    }
    
    /* システムOFF時の暗転 */
    .system-off #grid-container { opacity: 0.1; }
</style>
</head>
<body>
    <div id="connection-status">Connecting...</div>
    <div id="grid-container"></div>
    <div id="damage-flash"></div><div id="heal-flash"></div>
    <div id="game-over">SYSTEM DOWN</div>
    <div id="status-bar">DANGER: <span id="score-val">10000</span></div>

    <script>
        // 設定
        const MAX_DARKNESS = 20000; 
        const INITIAL_DARKNESS = 10000; 
        const DAMAGE_MULTIPLIER = 1.2; 
        
        // ★OBSの解像度に合わせて自動調整されますが、
        // 縦横のブロック数はここでお好みに調整できます
        const GRID_COLS = 32; 
        const GRID_ROWS = 18; 

        let currentDarkness = INITIAL_DARKNESS; 
        let spiralOrder = []; 
        let isActive = true;

        const container = document.getElementById('grid-container'); 
        const scoreVal = document.getElementById('score-val'); 
        const gameOverText = document.getElementById('game-over'); 
        const damageFlash = document.getElementById('damage-flash'); 
        const healFlash = document.getElementById('heal-flash'); 
        const statusText = document.getElementById('connection-status');

        container.style.setProperty('--cols', GRID_COLS); 
        container.style.setProperty('--rows', GRID_ROWS);

        // WebSocket接続
        function connectWS() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(protocol + '//' + window.location.host + '/ws');
            ws.onopen = () => { statusText.innerText = "●"; statusText.style.color = "#0f0"; };
            ws.onmessage = (event) => { 
                const data = JSON.parse(event.data); 
                if (data.type === 'damage') addDarkness(data.amount); 
                else if (data.type === 'heal') removeDarkness(data.amount);
                else if (data.type === 'status_change') updateSystemState(data.is_active);
            };
            ws.onclose = () => { statusText.innerText = "×"; statusText.style.color = "red"; setTimeout(connectWS, 3000); };
        }

        function updateSystemState(active) {
            isActive = active;
            if (isActive) document.body.classList.remove("system-off");
            else document.body.classList.add("system-off");
        }

        function initGrid() {
            let gridMap = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
            for (let r = 0; r < GRID_ROWS; r++) { for (let c = 0; c < GRID_COLS; c++) { const block = document.createElement('div'); block.classList.add('block'); container.appendChild(block); gridMap[r][c] = block; } }
            
            // 渦巻き順生成
            let top = 0, bottom = GRID_ROWS - 1, left = 0, right = GRID_COLS - 1; let dir = 0;
            while (top <= bottom && left <= right) {
                if (dir === 0) { for (let i = left; i <= right; i++) spiralOrder.push(gridMap[top][i]); top++; }
                else if (dir === 1) { for (let i = top; i <= bottom; i++) spiralOrder.push(gridMap[i][right]); right--; }
                else if (dir === 2) { for (let i = right; i >= left; i--) spiralOrder.push(gridMap[bottom][i]); bottom--; }
                else if (dir === 3) { for (let i = bottom; i >= top; i--) spiralOrder.push(gridMap[i][left]); left++; }
                dir = (dir + 1) % 4;
            }
            updateVisuals();
        }

        function updateVisuals() {
            scoreVal.innerText = Math.floor(currentDarkness);
            const blocksToDraw = Math.floor((currentDarkness / MAX_DARKNESS) * spiralOrder.length);
            spiralOrder.forEach((block, index) => { 
                if (index < blocksToDraw) { if (!block.classList.contains('active')) block.classList.add('active'); } 
                else { if (block.classList.contains('active')) block.classList.remove('active'); } 
            });
            
            if (currentDarkness >= MAX_DARKNESS) { 
                gameOverText.style.opacity = 1; gameOverText.innerText = "SYSTEM DOWN"; gameOverText.style.color = "red"; 
            } else if (currentDarkness <= 0) { 
                gameOverText.style.opacity = 1; gameOverText.innerText = "SURVIVED"; gameOverText.style.color = "#0f0"; 
            } else { 
                gameOverText.style.opacity = 0; 
            }
        }

        function addDarkness(amount) { 
            if (currentDarkness >= MAX_DARKNESS) return; 
            currentDarkness = Math.min(currentDarkness + (amount * DAMAGE_MULTIPLIER), MAX_DARKNESS); 
            damageFlash.style.backgroundColor = "rgba(255, 0, 0, 0.4)"; 
            setTimeout(() => { damageFlash.style.backgroundColor = "rgba(0,0,0,0)"; }, 100); 
            updateVisuals(); 
        }

        function removeDarkness(amount) { 
            if (currentDarkness <= 0) return; 
            currentDarkness = Math.max(currentDarkness - amount, 0); 
            healFlash.style.backgroundColor = "rgba(255, 255, 255, 0.5)"; 
            setTimeout(() => { healFlash.style.backgroundColor = "rgba(0,0,0,0)"; }, 150); 
            updateVisuals(); 
        }
        
        initGrid(); 
        connectWS();
        // 初期状態取得
        fetch('/api/status').then(r => r.json()).then(d => updateSystemState(d.is_active));
    </script>
</body>
</html>